import { walkSync } from "https://deno.land/std@0.171.0/fs/walk.ts";
import { join, dirname, fromFileUrl } from "https://deno.land/std@0.171.0/path/mod.ts";

// node style __dirname
const __dirname = dirname(fromFileUrl(import.meta.url));

/**
 * load all methods from functions.txt (generated by dllexp.exe from http://www.nirsoft.net/utils/dll_export_viewer.html)
 */
const data = Deno.readTextFileSync(join(__dirname, 'functions.txt'));
const methods = data.split(/[\r\n]/g).map(a => a.split('\t')[0]).filter(a => a);
console.log(`${methods.length} methods`);

const sourceDirectory = join(__dirname, "..", 'vips-dev-8.14');
const headers = walkSync(sourceDirectory, { exts: ['.h'] });

const allHeaders: { [key: string]: { source: string, code: string } } = {};
for (const header of headers) {
    const data = Deno.readTextFileSync(header.path);
    if (!data.includes('VIPS_API'))
        continue;
    allHeaders[header.name] = { source: data, code: '' };
}
/**
 * ignore deprecated methods
 */
const deprecatedSet = new Set(['vips_target_finish']);
/**
 * list of all return types meet in the headers files
 */
const allRetTypes = [
    'int ',
    'void ',
    'const char *',
    'VipsVector *',
    'GObject **',
    'VipsTargetCustom *',
    'VipsSource *',
    'VipsSourceCustom *',
    'VipsTarget *',
    'VipsThreadState *',
    'const void *',
    'VipsSourceGInputStream *',
    'VipsRegion *',
    'VipsImage **',
    'GSList *',
    'VipsObject *',
    'size_t ',
    'off_t ', //  off_t can be 32 bits on some platforms, so make sure we have a full 64.
    'guint64 ',
    'VipsInterpolate *',
    'double ',
    'GCond *',
    'VipsThing *',
    'VipsBlob *',
    'gchar **',
    'VipsSbuf *',
    'VipsObject **',
    'GMutex *',
    'VipsCoding ',
    'VipsPel *',
    'GInputStream *',
    'VipsArgumentFlags ',
    'unsigned char *',
    'float ',
    'VipsBuffer *',
    'VipsRect *',
    'VipsOperation *',
    'VipsArrayImage *',
    'VipsRefString *',
    'VipsOperationFlags ',
    'VipsInterpolateMethod ',
    'VipsArea *',
    'VipsInterpretation ',
    'VipsBandFormat ',
    'VipsArrayInt *',
    'GThread *',
    'VipsArrayDouble *',
    'const VipsObjectClass *',
    'gboolean ',
    'int *',
    'void *',
    'GType ',
    'gint64 ',
    'double *',
    'char *',
    'VipsForeignFlags ',
];
/**
 * map of all types to their deno native type
 */
const typeMapping: { [key: string]: Deno.NativeResultType } = {
    'int': 'i32',
    'void': 'void',
    'const char *': 'buffer',
    'const GValue *': 'pointer',
    'VipsSemaphore *': 'pointer',
    'GValue *': 'buffer',
    'VipsVector *': 'buffer',
    'GObject **': 'pointer',
    'void **': 'pointer',
    'VipsTargetCustom *': 'pointer',
    'VipsWindow *': 'pointer',
    'VipsSource *': 'buffer',
    'VipsSourceCustom *': 'buffer',
    'VipsTarget *': 'buffer',
    'VipsThreadState *': 'buffer',
    'const void *': 'buffer',
    'VipsSourceGInputStream *': 'buffer',
    'VipsRegion *': 'pointer',
    'VipsImage *': 'pointer',
    'const VipsImage *': 'pointer',
    'VipsImage **': 'pointer',
    'GSList *': 'buffer',
    'VipsObject *': 'buffer',
    'size_t *': 'buffer',
    'float *': 'buffer',
    'size_t': 'usize',
    'off_t': 'usize',
    'guint64': 'u64',
    'VipsInterpolate *': 'pointer',
    'double': 'f64',
    'GCond *': 'pointer',
    'VipsThing *': 'pointer',
    'VipsBlob *': 'pointer',
    'gchar **': 'pointer',
    'VipsSbuf *': 'pointer',
    'VipsObject **': 'pointer',
    'GMutex *': 'pointer',
    'VipsPel *': 'pointer',
    'GInputStream *': 'pointer',
    'VipsArgumentFlags': 'u32', // bitset
    'unsigned char *': 'buffer',
    'VipsBuffer *': 'pointer',
    'VipsRect *': 'pointer',
    'VipsOperation *': 'pointer',
    'VipsArrayImage *': 'pointer',
    'VipsRefString *': 'pointer',
    'VipsOperationFlags': 'pointer',
    'VipsInterpolateMethod': 'pointer',
    'VipsArea *': 'pointer',
    'VipsArrayInt *': 'pointer',
    'GThread *': 'pointer',
    'VipsArrayDouble *': 'pointer',
    'VipsObjectClass *': 'pointer',
    'const VipsObjectClass *': 'pointer',
    'gboolean': 'bool',
    'int *': 'buffer',
    'void *': 'pointer',
    'GType': 'i64',
    'GType *': 'pointer',
    'const int *': 'pointer',
    'gint64': 'i64',
    'double *': 'buffer',
    'char *': 'buffer',
    'VipsSListMap2Fn': 'function',

    // foreign.h
    'VipsForeignFlags': 'u32', // enum
    'VipsFailOn': 'u32', // enum

    // arithmetic.h
    'VipsOperationMath': 'u32', // enum
    'VipsOperationMath2': 'u32', // enum
    'VipsOperationRound': 'u32', // enum
    'VipsOperationRelational': 'u32', // enum
    'VipsOperationBoolean': 'u32', // enum
    'VipsOperationComplex': 'u32', // enum
    'VipsOperationComplex2': 'u32', // enum
    'VipsOperationComplexget': 'u32', // enum
    
    // conversion.h
    'VipsExtend': 'u32', // enum
    'VipsCompassDirection': 'u32', // enum
    'VipsDirection': 'u32', // enum
    'VipsAlign': 'u32', // enum
    'VipsAngle': 'u32', // enum
    'VipsAngle45': 'u32', // enum
    'VipsInteresting': 'u32', // enum
    'VipsBlendMode': 'u32', // enum
    
    // morphology.h
    'VipsOperationMorphology': 'u32', // enum

    // image.h
    'VipsDemandStyle': 'u32',
    'VipsImageType': 'u32', // enum
    'VipsInterpretation': 'u32', // enum
    'VipsBandFormat': 'u32', // enum
    'VipsCoding': 'u32', // enum
    'VipsAccess': 'u32', // enum
    'VipsBandFormat *': 'buffer', // list enf enum

    // Vimage8.h
    'VipsObjectSetArguments': 'function',

    // basic.h
    'VipsPrecision': 'u32', // enum
    "VipsPel" : 'u8',
    "const VipsPel *" : 'buffer',

    // region.h
    "VipsRegionShrink": 'u32', // 'enum',

    'unsigned char **': 'pointer',
    'const double *': 'buffer',
    'const VipsRect *': 'pointer',
    'double **': 'pointer',
    'int **': 'pointer',
    'VipsDbuf *': 'pointer',
    'const void **': 'pointer',
    'VipsBuf *': 'pointer',
    'VipsCallbackFn': 'function',
    'VipsExecutor *': 'pointer',
    'gboolean *': 'pointer',
    'GError **': 'pointer',
    'VipsConnection *': 'pointer',
    'GParamSpec *': 'pointer',
    'struct _VipsImage *': 'pointer',
    'struct _VipsRegion **': 'pointer',
    '_VipsRegion **': 'pointer',
    "GParamSpec **": 'pointer',
   
    "VipsArgumentInstance **": 'pointer',
    "const char ***": 'pointer',
    "GObject *": 'pointer',
    "VipsRegion **": 'pointer',
    "VipsOperation **": 'pointer',
    "struct _VipsRegion *": 'pointer',
    "GHashTable *": 'pointer',
    "char **": 'pointer',
    "FILE *": "pointer",
    "GOptionGroup *": "pointer",
    "VipsRegionWrite": "function",
    "VipsSinkNotify": "function",
    "VipsArgumentClass **": 'pointer',
    "VipsArgumentClass *": 'pointer',
    "VipsArgumentClass": "function",
    "VipsOperationClass *": 'pointer',
    "VipsBlob **": 'pointer',
    "const char **": 'pointer',
    "const unsigned char *": 'buffer',

    'float': 'f32',
    'char': 'i8', // or u8 ?
    "unsigned char": 'u8',
    'guint': 'u32',
    'va_list': 'pointer',
}

const retType = allRetTypes.map(a => a.replace('*', '\\*')).join('|')
// let err = 0;

for (const method of methods) {
    // if (!method.startsWith('vips_image_get'))
    //     continue;
    // if (method !== 'vips_foreign_png_filter_get_type')
    //     continue;
    if (deprecatedSet.has(method))
        continue;
    //const pat = `VIPS_API\s*[\r\n]+\s*(${retType})${method}\([\\r\\n\w ,*]*\)`;
    const pat = `VIPS_API\s*[\r\n]+\s*(${retType})${method} ?\\(([.\\r\\n\\w \t,*\\[\\]]*)\\)`;
    // console.log(pat)

    const theRegexp = new RegExp(pat, 'gm');
    let success = 0;
    for (const h of Object.values(allHeaders)) {
        const { source } = h;
        const m = [...source.matchAll(theRegexp)]
        if (!m.length)
            continue;
        const [_, type, params] = m[0];
        const type2 = typeMapping[type.trim()];
        const params2 = params.split(/,/g)
            .map(a => a.trim())
            .map(a => {
                if (a === '...') return 'void *args'
                return a
            })
            // .filter((a) => a != '...') // TODO need to implements va args
            // .filter((a) => !a.startsWith('va_list')); // TODO need to implements va args
        const params3: string[] = [];
        const name3: string[] = [];
        for (let param of params2) {
            param = param.replace(/;/g, '').trim();
            const p = param.lastIndexOf('*');
            if (p > 0) {
                params3.push(param.substring(0, p + 1).trim());
                name3.push(param.substring(p + 1));
                continue;
            }
            const p2 = param.lastIndexOf(' ');
            if (p2 > 0) {
                params3.push(param.substring(0, p2 + 1).trim());
                name3.push(param.substring(p2 + 1));
                continue;
            }
        }
        // Fn
        const paramsList = params3.map((a) => {
            const mapped = typeMapping[a];
            if (mapped) return mapped;
            if (a.endsWith('Fn'))
                return 'function';
            return `___${a}___`;
        }).map((a, i) => `  "${a}", // ${name3[i]} as ${params3[i]}`).join('\r\n  ');
        const line2 = `export const ${method} = {
  parameters: [
  ${paramsList}
  ],
  result: "${type2}"
} as const
`;
        h.code += '\r\n' + line2;
        success++;
        // if (!paramsList.includes('__'))
        //     console.log(line2);
    }
}

const destFolder = join(dirname(fromFileUrl(import.meta.url)), "..", 'lib', 'include');
Deno.mkdirSync(destFolder, { recursive: true });
for (const [name, h] of Object.entries(allHeaders)) {
    const destFile = join(destFolder, `${name}.ts`);
    if (!h.code)
        continue;
    const code =  `// this code is generarated by ${import.meta.url}\r\n${h.code}`;
    Deno.writeTextFileSync(destFile, code);
}

